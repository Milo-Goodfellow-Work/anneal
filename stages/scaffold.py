"""
Anneal Stages - Scaffold generation and write lockdown.

This module handles auto-generating the Lean file structure.
"""
from __future__ import annotations
import json
from pathlib import Path
from typing import Dict, List, Any

from helpers import (
    log, _read_text_file, _write_text_file,
    list_project_files, _is_source_file, _lean_out_path_for_source,
    module_name_from_lean_path, ensure_prelude_and_lockdown,
    SPEC_DIR, SPEC_SRC_DIR, SPEC_TESTS_DIR, SPEC_REPORTS_DIR,
    DIFF_REQUIRED_RUNS, DIFF_MIN_CASES_PER_RUN,
)


def _register_module_in_package_root(ctx: dict) -> None:
    """Ensure spec/Spec.lean imports Spec.<project>."""
    spec_file = ctx["spec_src_root"].parent / "Spec.lean"  # spec/Spec.lean
    line = f"import Spec.{ctx['name']}"
    if spec_file.exists():
        content = _read_text_file(spec_file)
        if line not in content:
            _write_text_file(spec_file, content.rstrip() + "\n" + line + "\n")
    else:
        _write_text_file(spec_file, line + "\n")


def _write_project_root_module_locked(ctx: dict, project_module_paths: List[str]) -> None:
    """Write spec/Spec/<project>.lean importing all project submodules."""
    imports: List[str] = []
    for rel in project_module_paths:
        p = Path(rel)
        if p.suffix != ".lean":
            continue
        mod = "Spec." + ".".join(p.with_suffix("").parts)
        imports.append(f"import {mod}")

    # Always import Verif.lean so it is included in the project build
    imports.append(f"import Spec.{ctx['name']}.Verif")

    root_rel = f"{ctx['name']}.lean"
    body = "\n".join(sorted(set(imports))) + "\n"
    _write_text_file(ctx["spec_src_root"] / root_rel, body)
    ctx["locked_lean_paths"].add(root_rel)


def _load_equiv_report_if_present(ctx: dict) -> None:
    """Load persisted equivalence report if it exists."""
    p = Path(ctx["equiv_report_rel"])
    if not p.exists():
        return
    try:
        rep = json.loads(_read_text_file(p))
        if isinstance(rep, dict) and rep.get("status") == "success":
            ctx["equiv_state"]["last_report"] = rep
            ctx["equiv_state"]["last_status"] = "success"
            ctx["equiv_state"]["passed_runs"] = int(rep.get("passed_runs", 0))
            ctx["equiv_state"]["required_runs"] = int(rep.get("required_runs", DIFF_REQUIRED_RUNS))
            ctx["equiv_state"]["min_cases_per_run"] = int(rep.get("min_cases_per_run", DIFF_MIN_CASES_PER_RUN))
    except Exception:
        return


def autogen_scaffold_and_lockdown(ctx: dict) -> None:
    """
    Auto-generate the Lean file structure inside spec/Spec and lock down writes.
    """
    ensure_prelude_and_lockdown()

    files = list_project_files(ctx["source_root"])
    src_files = [f for f in files if _is_source_file(f)]
    if not src_files:
        log(f"No C/C++ source files found under {ctx['source_root']}")
        return

    used_names: Dict[str, int] = {}
    project_module_paths: List[str] = []

    ctx["src_to_lean"].clear()
    ctx["lean_to_src"].clear()

    for rel in src_files:
        out_rel = _lean_out_path_for_source(ctx["name"], rel, used_names)
        ctx["src_to_lean"][rel] = out_rel
        ctx["lean_to_src"][out_rel] = rel
        project_module_paths.append(out_rel)

    # Autogenerate stub modules (model-writable)
    ctx["allowed_lean_writes"] = set(project_module_paths)

    for out_rel in project_module_paths:
        p = ctx["spec_src_root"] / out_rel
        if not p.exists():
            stub = (
                "import Spec.Prelude\n\n"
                f"namespace Spec.{ctx['name']}\n\n"
                f"-- AUTOGENERATED STUB\n"
                f"-- Source: {ctx['lean_to_src'].get(out_rel, '(unknown)')}\n"
                f"-- SAFETY-CRITICAL MODE: you must implement full semantics; no placeholders/stubs.\n\n"
                f"end Spec.{ctx['name']}\n"
            )
            _write_text_file(p, stub)

    # Verif module (model-writable but stage-gated)
    verif_rel = f"{ctx['name']}/Verif.lean"
    ctx["allowed_lean_writes"].add(verif_rel)
    if not (ctx["spec_src_root"] / verif_rel).exists():
        verif_stub = (
            "import Spec.Prelude\n\n"
            f"namespace Spec.{ctx['name']}\n\n"
            "-- AUTOGENERATED SPEC STUB (PROOFS-ONLY)\n"
            "-- This file is imported for Aristotle; to prevent smuggling it must not define executable entities.\n"
            "-- You may write theorems/lemmas here; 'sorry' is allowed here only.\n\n"
            f"end Spec.{ctx['name']}\n"
        )
        _write_text_file(ctx["spec_src_root"] / verif_rel, verif_stub)

    # Lean harness (model-writable)
    harness_rel = "tests/Harness.lean"
    ctx["allowed_lean_writes"].add(harness_rel)
    harness_path = ctx["spec_src_root"] / harness_rel
    if not harness_path.exists():
        harness_stub = (
            "import Spec.Prelude\n"
            f"import Spec.{ctx['name']}\n\n"
            f"namespace Spec.{ctx['name']}\n\n"
            "-- AUTOGENERATED HARNESS STUB\n"
            "-- Implement a fast stdin parser and deterministic stdout printer.\n"
            "-- Must be efficient: avoid slow per-line IO and quadratic string concatenation.\n\n"
            "def main : IO Unit := do\n"
            "  -- Implement command loop\n"
            "  pure ()\n\n"
            f"end Spec.{ctx['name']}\n"
        )
        _write_text_file(harness_path, harness_stub)

    # Autogenerate non-Lean harness files in spec/tests (model-writable)
    SPEC_TESTS_DIR.mkdir(parents=True, exist_ok=True)
    SPEC_REPORTS_DIR.mkdir(parents=True, exist_ok=True)

    gen_rel = "spec/tests/gen_inputs.py"
    c_rel = "spec/tests/harness.c"
    ctx["allowed_text_writes"] = {gen_rel, c_rel, ctx["safety_case_rel"]}

    if not Path(gen_rel).exists():
        _write_text_file(Path(gen_rel),
            "#!/usr/bin/env python3\n"
            "import argparse\n"
            "import random\n"
            "\n"
            "# AUTOGENERATED GENERATOR STUB\n"
            "# Contract: must accept --seed INT and --n INT and print >= n non-empty command lines.\n"
            "# Output is fed verbatim to both harnesses.\n"
            "\n"
            "def main():\n"
            "    ap = argparse.ArgumentParser()\n"
            "    ap.add_argument('--seed', type=int, required=True)\n"
            "    ap.add_argument('--n', type=int, required=True)\n"
            "    args = ap.parse_args()\n"
            "    random.seed(args.seed)\n"
            "    for _ in range(args.n):\n"
            "        print('NOOP')\n"
            "\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
        )

    if not Path(c_rel).exists():
        _write_text_file(Path(c_rel),
            "/* AUTOGENERATED C HARNESS STUB\n"
            " * Read commands from stdin, execute against the C implementation, and print deterministic stdout.\n"
            " * Must match Lean harness output exactly.\n"
            " */\n"
            "#include <stdio.h>\n"
            "#include <string.h>\n"
            "\n"
            "int main(void) {\n"
            "    char buf[512];\n"
            "    while (fgets(buf, sizeof(buf), stdin)) {\n"
            "        size_t n = strlen(buf);\n"
            "        while (n && (buf[n-1] == '\\n' || buf[n-1] == '\\r')) { buf[n-1] = 0; n--; }\n"
            "        if (n == 0) continue;\n"
            "        // TODO: parse and execute commands; print results\n"
            "        if (strcmp(buf, \"NOOP\") == 0) {\n"
            "            puts(\"OK\");\n"
            "        } else {\n"
            "            puts(\"ERR\");\n"
            "        }\n"
            "    }\n"
            "    return 0;\n"
            "}\n"
        )

    # Autogenerate safety case placeholder (model-writable)
    if not Path(ctx["safety_case_rel"]).exists():
        _write_text_file(Path(ctx["safety_case_rel"]),
            f"# Safety Case (AUTOGENERATED)\n\n"
            f"Project: `{ctx['name']}`\n\n"
            f"> This file must be rewritten by the agent during the HARDENING stage.\n"
        )

    # Write project root module (locked)
    _write_project_root_module_locked(ctx, project_module_paths)

    # Ensure package root imports project
    _register_module_in_package_root(ctx)

    # Lock Prelude and project root module
    ctx["locked_lean_paths"].add("Prelude.lean")
    ctx["locked_lean_paths"].add(f"{ctx['name']}.lean")

    # Load persisted equivalence report if present
    _load_equiv_report_if_present(ctx)

    log("Autogenerated Spec/Spec scaffold and locked down writes.")
    log(f"Locked Lean files (read-only for model): {sorted(ctx['locked_lean_paths'])}")
    log(f"Writable Lean files (model may edit): {len(ctx['allowed_lean_writes'])} files")
    log(f"Writable text files (model may edit): {sorted(ctx['allowed_text_writes'])}")
