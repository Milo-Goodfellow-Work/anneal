"""
Anneal Stages - Scaffold generation and write lockdown.

This module handles auto-generating the Lean file structure.
"""
from __future__ import annotations
import json
from pathlib import Path
from typing import Dict, List, Any

from helpers import (
    log, _read_text_file, _write_text_file,
    list_project_files, _is_source_file, _lean_out_path_for_source,
    module_name_from_lean_path, ensure_prelude_and_lockdown,
    SPEC_DIR, SPEC_SRC_DIR, SPEC_TESTS_DIR, SPEC_REPORTS_DIR,
    DIFF_REQUIRED_RUNS, DIFF_MIN_CASES_PER_RUN,
)


def create_project_from_prompt(ctx: dict) -> None:
    """
    Create empty project structure for prompt-driven generation.
    
    Unlike autogen_scaffold_and_lockdown (which reads existing source files),
    this creates a blank slate where the model will generate both impl + Lean.
    """
    ensure_prelude_and_lockdown()
    
    project_name = ctx["name"]
    language = ctx.get("language", "c")
    
    log(f"Creating prompt-driven project scaffold: {project_name} ({language})")
    
    # Create directories
    SPEC_TESTS_DIR.mkdir(parents=True, exist_ok=True)
    SPEC_REPORTS_DIR.mkdir(parents=True, exist_ok=True)
    ctx["spec_project_root"].mkdir(parents=True, exist_ok=True)
    ctx["source_root"].mkdir(parents=True, exist_ok=True)
    
    # Set up writable paths for generated code
    # Implementation files (dynamic - model creates as needed)
    impl_ext = {"c": [".c", ".h"], "python": [".py"], "rust": [".rs"]}
    ctx["impl_extensions"] = impl_ext.get(language, [".c", ".h"])
    
    # Lean files the model can create
    main_lean = f"{project_name}/Main.lean"
    verif_lean = f"{project_name}/Verif.lean"
    harness_lean = "tests/Harness.lean"
    
    ctx["allowed_lean_writes"] = {main_lean, verif_lean, harness_lean}
    
    # Allow model to create implementation source files
    ctx["allowed_impl_writes"] = set()  # Will be populated dynamically
    
    # Allow model to also create additional Lean modules
    for i in range(1, 6):  # Allow up to 5 additional modules
        ctx["allowed_lean_writes"].add(f"{project_name}/Module{i}.lean")
    
    # Test harness files
    gen_rel = "spec/tests/gen_inputs.py"
    c_harness_rel = "spec/tests/harness.c"
    ctx["allowed_text_writes"] = {gen_rel, c_harness_rel, ctx["safety_case_rel"]}
    
    # Create stub Lean files
    main_lean_path = ctx["spec_src_root"] / main_lean
    if not main_lean_path.exists():
        stub = (
            "import Spec.Prelude\n\n"
            f"namespace Spec.{project_name}\n\n"
            "-- PROMPT-DRIVEN GENERATION\n"
            "-- The agent will generate Lean definitions here based on the user's prompt.\n"
            "-- This code must be semantically equivalent to the generated implementation.\n\n"
            f"end Spec.{project_name}\n"
        )
        _write_text_file(main_lean_path, stub)
    
    # Create Verif stub - imports Main.lean directly to avoid circular dependency
    verif_path = ctx["spec_src_root"] / verif_lean
    if not verif_path.exists():
        verif_stub = (
            "import Spec.Prelude\n"
            f"import Spec.{project_name}.Main\n\n"
            f"namespace Spec.{project_name}\n\n"
            "-- SPECIFICATIONS (generated by Aristotle)\n"
            "-- This file will contain theorems and proofs.\n\n"
            f"end Spec.{project_name}\n"
        )
        _write_text_file(verif_path, verif_stub)
    
    # Create harness stub with WORKING IO example
    harness_path = ctx["spec_src_root"] / harness_lean
    harness_path.parent.mkdir(parents=True, exist_ok=True)
    if not harness_path.exists():
        harness_stub = (
            "import Spec.Prelude\n"
            f"import Spec.{project_name}\n\n"
            f"namespace Spec.{project_name}\n\n"
            "-- DIFFERENTIAL TEST HARNESS\n"
            "-- Reads commands from stdin, executes Lean implementation, prints results.\n"
            "-- Must produce IDENTICAL output to the C harness.\n\n"
            "-- Helper: Read all stdin lines\n"
            "partial def readLines (acc : List String) : IO (List String) := do\n"
            "  let stdin ← IO.getStdin\n"
            "  let line ← stdin.getLine\n"
            "  if line.isEmpty then\n"
            "    return acc.reverse\n"
            "  else\n"
            "    readLines (line.trim :: acc)\n\n"
            "def main : IO Unit := do\n"
            "  let lines ← readLines []\n"
            "  -- TODO: Process each line as a command\n"
            "  for line in lines do\n"
            "    -- Example: parse command and execute\n"
            "    if line == \"NOOP\" then\n"
            "      IO.println \"OK\"\n"
            "    else\n"
            "      IO.println \"ERR\"\n\n"
            f"end Spec.{project_name}\n"
        )
        _write_text_file(harness_path, harness_stub)
    
    # Create gen_inputs.py stub
    if not Path(gen_rel).exists():
        _write_text_file(Path(gen_rel),
            "#!/usr/bin/env python3\n"
            "import argparse\n"
            "import random\n"
            "\n"
            "# Input generator for differential testing\n"
            "# Must accept --seed INT and --n INT\n"
            "\n"
            "def main():\n"
            "    ap = argparse.ArgumentParser()\n"
            "    ap.add_argument('--seed', type=int, required=True)\n"
            "    ap.add_argument('--n', type=int, required=True)\n"
            "    args = ap.parse_args()\n"
            "    random.seed(args.seed)\n"
            "    for _ in range(args.n):\n"
            "        print('NOOP')  # TODO: Generate real test commands\n"
            "\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
        )
    
    # Create C harness stub
    if not Path(c_harness_rel).exists():
        _write_text_file(Path(c_harness_rel),
            "/* Differential test harness for generated C implementation */\n"
            "#include <stdio.h>\n"
            "#include <string.h>\n"
            "\n"
            "int main(void) {\n"
            "    char buf[512];\n"
            "    while (fgets(buf, sizeof(buf), stdin)) {\n"
            "        size_t n = strlen(buf);\n"
            "        while (n && (buf[n-1] == '\\n' || buf[n-1] == '\\r')) { buf[n-1] = 0; n--; }\n"
            "        if (n == 0) continue;\n"
            "        // TODO: Parse and execute commands\n"
            "        if (strcmp(buf, \"NOOP\") == 0) {\n"
            "            puts(\"OK\");\n"
            "        } else {\n"
            "            puts(\"ERR\");\n"
            "        }\n"
            "    }\n"
            "    return 0;\n"
            "}\n"
        )
    
    # Create project root module
    root_module = ctx["spec_src_root"] / f"{project_name}.lean"
    if not root_module.exists():
        root_content = (
            f"import Spec.{project_name}.Main\n"
            f"import Spec.{project_name}.Verif\n"
        )
        _write_text_file(root_module, root_content)
    
    # Register in package root
    spec_file = ctx["spec_src_root"].parent / "Spec.lean"
    line = f"import Spec.{project_name}"
    if spec_file.exists():
        content = _read_text_file(spec_file)
        if line not in content:
            _write_text_file(spec_file, content.rstrip() + "\n" + line + "\n")
    else:
        _write_text_file(spec_file, line + "\n")
    
    # Lock read-only files
    ctx["locked_lean_paths"].add("Prelude.lean")
    ctx["locked_lean_paths"].add(f"{project_name}.lean")
    
    # Create src_to_lean mapping (empty for prompt mode - will be filled by agent)
    ctx["src_to_lean"] = {"(prompt)": main_lean}
    ctx["lean_to_src"] = {main_lean: "(prompt)"}
    
    log(f"Scaffold created: {len(ctx['allowed_lean_writes'])} writable Lean files")
    log(f"Implementation goes in: {ctx['source_root']}")





def _register_module_in_package_root(ctx: dict) -> None:
    """Ensure spec/Spec.lean imports Spec.<project>."""
    spec_file = ctx["spec_src_root"].parent / "Spec.lean"  # spec/Spec.lean
    line = f"import Spec.{ctx['name']}"
    if spec_file.exists():
        content = _read_text_file(spec_file)
        if line not in content:
            _write_text_file(spec_file, content.rstrip() + "\n" + line + "\n")
    else:
        _write_text_file(spec_file, line + "\n")


def _write_project_root_module_locked(ctx: dict, project_module_paths: List[str]) -> None:
    """Write spec/Spec/<project>.lean importing all project submodules."""
    imports: List[str] = []
    for rel in project_module_paths:
        p = Path(rel)
        if p.suffix != ".lean":
            continue
        mod = "Spec." + ".".join(p.with_suffix("").parts)
        imports.append(f"import {mod}")

    # Always import Verif.lean so it is included in the project build
    imports.append(f"import Spec.{ctx['name']}.Verif")

    root_rel = f"{ctx['name']}.lean"
    body = "\n".join(sorted(set(imports))) + "\n"
    _write_text_file(ctx["spec_src_root"] / root_rel, body)
    ctx["locked_lean_paths"].add(root_rel)


def _load_equiv_report_if_present(ctx: dict) -> None:
    """Load persisted equivalence report if it exists."""
    p = Path(ctx["equiv_report_rel"])
    if not p.exists():
        return
    try:
        rep = json.loads(_read_text_file(p))
        if isinstance(rep, dict) and rep.get("status") == "success":
            ctx["equiv_state"]["last_report"] = rep
            ctx["equiv_state"]["last_status"] = "success"
            ctx["equiv_state"]["passed_runs"] = int(rep.get("passed_runs", 0))
            ctx["equiv_state"]["required_runs"] = int(rep.get("required_runs", DIFF_REQUIRED_RUNS))
            ctx["equiv_state"]["min_cases_per_run"] = int(rep.get("min_cases_per_run", DIFF_MIN_CASES_PER_RUN))
    except Exception:
        return


def autogen_scaffold_and_lockdown(ctx: dict) -> None:
    """
    Auto-generate the Lean file structure inside spec/Spec and lock down writes.
    """
    ensure_prelude_and_lockdown()

    files = list_project_files(ctx["source_root"])
    src_files = [f for f in files if _is_source_file(f)]
    if not src_files:
        log(f"No C/C++ source files found under {ctx['source_root']}")
        return

    used_names: Dict[str, int] = {}
    project_module_paths: List[str] = []

    ctx["src_to_lean"].clear()
    ctx["lean_to_src"].clear()

    for rel in src_files:
        out_rel = _lean_out_path_for_source(ctx["name"], rel, used_names)
        ctx["src_to_lean"][rel] = out_rel
        ctx["lean_to_src"][out_rel] = rel
        project_module_paths.append(out_rel)

    # Autogenerate stub modules (model-writable)
    ctx["allowed_lean_writes"] = set(project_module_paths)

    for out_rel in project_module_paths:
        p = ctx["spec_src_root"] / out_rel
        if not p.exists():
            stub = (
                "import Spec.Prelude\n\n"
                f"namespace Spec.{ctx['name']}\n\n"
                f"-- AUTOGENERATED STUB\n"
                f"-- Source: {ctx['lean_to_src'].get(out_rel, '(unknown)')}\n"
                f"-- SAFETY-CRITICAL MODE: you must implement full semantics; no placeholders/stubs.\n\n"
                f"end Spec.{ctx['name']}\n"
            )
            _write_text_file(p, stub)

    # Verif module (model-writable but stage-gated)
    # Imports Main.lean directly to avoid circular dependency with project root
    verif_rel = f"{ctx['name']}/Verif.lean"
    ctx["allowed_lean_writes"].add(verif_rel)
    if not (ctx["spec_src_root"] / verif_rel).exists():
        # Find the first implementation module to import
        impl_modules = [p for p in project_module_paths if not p.endswith("Verif.lean")]
        first_impl = impl_modules[0] if impl_modules else None
        
        if first_impl:
            # Import specific implementation file (e.g., Engine.lean)
            mod_name = "Spec." + ".".join(Path(first_impl).with_suffix("").parts)
            import_line = f"import {mod_name}\n"
        else:
            import_line = ""
        
        verif_stub = (
            "import Spec.Prelude\n"
            f"{import_line}\n"
            f"namespace Spec.{ctx['name']}\n\n"
            "-- AUTOGENERATED SPEC STUB (PROOFS-ONLY)\n"
            "-- This file is imported for Aristotle; to prevent smuggling it must not define executable entities.\n"
            "-- You may write theorems/lemmas here; 'sorry' is allowed here only.\n\n"
            f"end Spec.{ctx['name']}\n"
        )
        _write_text_file(ctx["spec_src_root"] / verif_rel, verif_stub)

    # Lean harness (model-writable) with WORKING IO example
    harness_rel = "tests/Harness.lean"
    ctx["allowed_lean_writes"].add(harness_rel)
    harness_path = ctx["spec_src_root"] / harness_rel
    if not harness_path.exists():
        harness_stub = (
            "import Spec.Prelude\n"
            f"import Spec.{ctx['name']}\n\n"
            f"namespace Spec.{ctx['name']}\n\n"
            "-- DIFFERENTIAL TEST HARNESS\n"
            "-- Read commands from stdin, execute, print deterministic output.\n"
            "-- Output must EXACTLY match the C harness.\n\n"
            "-- Helper: Read all stdin lines (WORKING CODE - use this pattern)\n"
            "partial def readLines (acc : List String) : IO (List String) := do\n"
            "  let stdin ← IO.getStdin\n"
            "  let line ← stdin.getLine\n"
            "  if line.isEmpty then\n"
            "    return acc.reverse\n"
            "  else\n"
            "    readLines (line.trim :: acc)\n\n"
            "def main : IO Unit := do\n"
            "  let lines ← readLines []\n"
            "  -- Process each line as a command\n"
            "  for line in lines do\n"
            "    -- TODO: Parse command and call implementation\n"
            "    if line == \"NOOP\" then\n"
            "      IO.println \"OK\"\n"
            "    else\n"
            "      IO.println \"ERR\"\n\n"
            f"end Spec.{ctx['name']}\n"
        )
        _write_text_file(harness_path, harness_stub)

    # Autogenerate non-Lean harness files in spec/tests (model-writable)
    SPEC_TESTS_DIR.mkdir(parents=True, exist_ok=True)
    SPEC_REPORTS_DIR.mkdir(parents=True, exist_ok=True)

    gen_rel = "spec/tests/gen_inputs.py"
    c_rel = "spec/tests/harness.c"
    ctx["allowed_text_writes"] = {gen_rel, c_rel, ctx["safety_case_rel"]}

    if not Path(gen_rel).exists():
        _write_text_file(Path(gen_rel),
            "#!/usr/bin/env python3\n"
            "import argparse\n"
            "import random\n"
            "\n"
            "# AUTOGENERATED GENERATOR STUB\n"
            "# Contract: must accept --seed INT and --n INT and print >= n non-empty command lines.\n"
            "# Output is fed verbatim to both harnesses.\n"
            "\n"
            "def main():\n"
            "    ap = argparse.ArgumentParser()\n"
            "    ap.add_argument('--seed', type=int, required=True)\n"
            "    ap.add_argument('--n', type=int, required=True)\n"
            "    args = ap.parse_args()\n"
            "    random.seed(args.seed)\n"
            "    for _ in range(args.n):\n"
            "        print('NOOP')\n"
            "\n"
            "if __name__ == '__main__':\n"
            "    main()\n"
        )

    if not Path(c_rel).exists():
        _write_text_file(Path(c_rel),
            "/* AUTOGENERATED C HARNESS STUB\n"
            " * Read commands from stdin, execute against the C implementation, and print deterministic stdout.\n"
            " * Must match Lean harness output exactly.\n"
            " */\n"
            "#include <stdio.h>\n"
            "#include <string.h>\n"
            "\n"
            "int main(void) {\n"
            "    char buf[512];\n"
            "    while (fgets(buf, sizeof(buf), stdin)) {\n"
            "        size_t n = strlen(buf);\n"
            "        while (n && (buf[n-1] == '\\n' || buf[n-1] == '\\r')) { buf[n-1] = 0; n--; }\n"
            "        if (n == 0) continue;\n"
            "        // TODO: parse and execute commands; print results\n"
            "        if (strcmp(buf, \"NOOP\") == 0) {\n"
            "            puts(\"OK\");\n"
            "        } else {\n"
            "            puts(\"ERR\");\n"
            "        }\n"
            "    }\n"
            "    return 0;\n"
            "}\n"
        )

    # Autogenerate safety case placeholder (model-writable)
    if not Path(ctx["safety_case_rel"]).exists():
        _write_text_file(Path(ctx["safety_case_rel"]),
            f"# Safety Case (AUTOGENERATED)\n\n"
            f"Project: `{ctx['name']}`\n\n"
            f"> This file must be rewritten by the agent during the HARDENING stage.\n"
        )

    # Write project root module (locked)
    _write_project_root_module_locked(ctx, project_module_paths)

    # Ensure package root imports project
    _register_module_in_package_root(ctx)

    # Lock Prelude and project root module
    ctx["locked_lean_paths"].add("Prelude.lean")
    ctx["locked_lean_paths"].add(f"{ctx['name']}.lean")

    # Load persisted equivalence report if present
    _load_equiv_report_if_present(ctx)

    log("Autogenerated Spec/Spec scaffold and locked down writes.")
    log(f"Locked Lean files (read-only for model): {sorted(ctx['locked_lean_paths'])}")
    log(f"Writable Lean files (model may edit): {len(ctx['allowed_lean_writes'])} files")
    log(f"Writable text files (model may edit): {sorted(ctx['allowed_text_writes'])}")
