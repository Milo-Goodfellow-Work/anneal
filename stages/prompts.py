"""
Anneal Stages - Prompt builders and base instructions.

These are procedural functions that generate prompts for the LLM.
"""
from __future__ import annotations
from typing import Optional, List, Dict
from pathlib import Path

from helpers import (
    SPEC_DIR, SPEC_SRC_DIR, list_lean_files, list_project_files,
    _is_source_file, _limit_lines, trunc, _read_text_file,
)


def locked_files_for_prompt(ctx: dict) -> str:
    """Return locked files for prompt."""
    return "\n".join(sorted(ctx["locked_lean_paths"]))


def spec_layout_for_prompt(ctx: dict) -> str:
    """Return spec layout for prompt."""
    files = list_lean_files(ctx["spec_src_root"])
    lines = _limit_lines([f"  {f}" for f in files], 80)
    return "\n".join(lines)


def source_layout_for_prompt(ctx: dict) -> str:
    """Return source layout for prompt."""
    files = [f for f in list_project_files(ctx["source_root"]) if _is_source_file(f)]
    lines = _limit_lines([f"  {f}" for f in files], 120)
    return "\n".join(lines)


def mapping_for_prompt(ctx: dict) -> str:
    """Return source->Lean mapping for prompt."""
    lines = [f"  {s} -> {t}" for s, t in sorted(ctx["src_to_lean"].items())]
    return "\n".join(_limit_lines(lines, 80))


def writable_files_for_prompt(ctx: dict) -> str:
    """Return writable files for prompt."""
    return "\n".join(sorted(ctx["allowed_lean_writes"]))


def base_instructions(ctx: dict, stage: str, focus_src: Optional[str] = None, focus_out: Optional[str] = None) -> str:
    """Generate base instructions for LLM."""
    focus_lines = ""
    if focus_src and focus_out:
        focus_lines = (
            f"FOCUS FILE (source -> target): {focus_src}  ->  {focus_out}\n"
            f"You must ultimately update ONLY: {focus_out}\n"
        )

    return (
        "ROLE: You are Anneal's translation engine: an expert engineer translating arbitrary input source code into Lean 4.\n"
        "SETTING: SAFETY-CRITICAL. You must assume correctness is mandatory. No placeholders, no stubs, no 'return true'.\n"
        "OBJECTIVE: produce Lean 4 code that compiles in the Lake project under spec/ and matches C semantics.\n\n"
        f"STAGE: {stage}\n"
        f"PROJECT: {ctx['name']}\n"
        f"SOURCE ROOT: {ctx['source_root']}\n"
        f"SPEC ROOT: {SPEC_DIR}\n"
        f"SPEC SOURCE ROOT: {SPEC_SRC_DIR}\n\n"
        f"{focus_lines}"
        "HARD CONSTRAINTS (enforced by runner):\n"
        "- You may ONLY write Lean files that were autogenerated by the runner.\n"
        "- Locked Lean files are read-only (do not attempt to modify them):\n"
        f"{locked_files_for_prompt(ctx)}\n\n"
        "- Import policy for generated modules:\n"
        "  * Each generated module MUST include 'import Spec.Prelude'.\n"
        "  * Do NOT import Std or Mathlib directly inside generated modules.\n"
        "  * You may import Spec.<project>.* only if necessary.\n\n"
        "CURRENT SPEC LAYOUT (key Lean files):\n"
        f"{spec_layout_for_prompt(ctx)}\n\n"
        "CURRENT SOURCE LAYOUT (C/C++ files):\n"
        f"{source_layout_for_prompt(ctx)}\n\n"
        "SOURCE -> LEAN MAPPING (autogenerated):\n"
        f"{mapping_for_prompt(ctx)}\n\n"
        "LEAN FILES YOU ARE ALLOWED TO WRITE:\n"
        f"{writable_files_for_prompt(ctx)}\n\n"
        "SAFETY-CRITICAL RULES:\n"
        "- Never insert placeholder behavior. If you cannot implement something, you must read more files and implement it.\n"
        "- Do not 'assume true', 'stub', 'simplify away' semantics, or explain that you'd do more later.\n"
        "- Translated/runtime modules MUST NOT use 'sorry'. Only Verif.lean may contain sorry.\n"
        "- Verif.lean is proofs-only (anti-smuggling): no defs/instances/axioms/macros.\n\n"
        "WORKING STYLE:\n"
        "- Prefer simple, dependable data structures first (List/Array/Option/Nat/Int) *as long as semantics match*.\n"
        "- Keep IO minimal and deterministic.\n"
        "- When fixing build errors: resolve the first error with the smallest correct change.\n"
    )


def project_summary(ctx: dict) -> str:
    """Generate a project summary for translation."""
    from stages.llm import responses_create
    
    files = list_project_files(ctx["source_root"])
    src_files = [f for f in files if _is_source_file(f)]
    blobs: List[str] = []
    for rel in src_files[:8]:
        txt = _read_text_file(ctx["source_root"] / rel)
        blobs.append(f"FILE: {rel}\n" + trunc(txt, 2800) + "\n")
    
    instructions = (
        "Summarize this C/C++ codebase for a Lean translator.\n"
        "Return a concise, technical summary: key data structures, APIs, invariants, and control flow.\n"
        "Assume this is safety-critical production code.\n"
    )
    resp = responses_create(ctx, instructions=instructions, input_data="\n".join(blobs))
    summary = getattr(resp, "output_text", None) or "No summary."
    return summary
