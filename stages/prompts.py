"""
Anneal Stages - Prompt builders and base instructions.

These are procedural functions that generate prompts for the LLM.
"""
from __future__ import annotations
from typing import Optional, List, Dict
from pathlib import Path

from helpers import (
    SPEC_DIR, SPEC_SRC_DIR, list_lean_files, list_project_files,
    _is_source_file, _limit_lines, trunc, _read_text_file,
)


def locked_files_for_prompt(ctx: dict) -> str:
    """Return locked files for prompt."""
    return "\n".join(sorted(ctx["locked_lean_paths"]))


def spec_layout_for_prompt(ctx: dict) -> str:
    """Return spec layout for prompt."""
    files = list_lean_files(ctx["spec_src_root"])
    lines = _limit_lines([f"  {f}" for f in files], 80)
    return "\n".join(lines)


def source_layout_for_prompt(ctx: dict) -> str:
    """Return source layout for prompt."""
    files = [f for f in list_project_files(ctx["source_root"]) if _is_source_file(f)]
    lines = _limit_lines([f"  {f}" for f in files], 120)
    return "\n".join(lines)


def mapping_for_prompt(ctx: dict) -> str:
    """Return source->Lean mapping for prompt."""
    lines = [f"  {s} -> {t}" for s, t in sorted(ctx["src_to_lean"].items())]
    return "\n".join(_limit_lines(lines, 80))


def writable_files_for_prompt(ctx: dict) -> str:
    """Return writable files for prompt."""
    return "\n".join(sorted(ctx["allowed_lean_writes"]))


def base_instructions(ctx: dict, stage: str, focus_src: Optional[str] = None, focus_out: Optional[str] = None) -> str:
    """Generate base instructions for LLM."""
    focus_lines = ""
    if focus_src and focus_out:
        focus_lines = (
            f"FOCUS FILE (source -> target): {focus_src}  ->  {focus_out}\n"
            f"You must ultimately update ONLY: {focus_out}\n"
        )

    return (
        "ROLE: You are Anneal's translation engine: an expert engineer translating arbitrary input source code into Lean 4.\n"
        "SETTING: SAFETY-CRITICAL. You must assume correctness is mandatory. No placeholders, no stubs, no 'return true'.\n"
        "OBJECTIVE: produce Lean 4 code that compiles in the Lake project under spec/ and matches C semantics.\n\n"
        f"STAGE: {stage}\n"
        f"PROJECT: {ctx['name']}\n"
        f"SOURCE ROOT: {ctx['source_root']}\n"
        f"SPEC ROOT: {SPEC_DIR}\n"
        f"SPEC SOURCE ROOT: {SPEC_SRC_DIR}\n\n"
        f"{focus_lines}"
        "HARD CONSTRAINTS (enforced by runner):\n"
        "- You may ONLY write Lean files that were autogenerated by the runner.\n"
        "- Locked Lean files are read-only (do not attempt to modify them):\n"
        f"{locked_files_for_prompt(ctx)}\n\n"
        "- Import policy for generated modules:\n"
        "  * Each generated module MUST include 'import Spec.Prelude'.\n"
        "  * Do NOT import Std or Mathlib directly inside generated modules.\n"
        "  * You may import Spec.<project>.* only if necessary.\n\n"
        "CURRENT SPEC LAYOUT (key Lean files):\n"
        f"{spec_layout_for_prompt(ctx)}\n\n"
        "CURRENT SOURCE LAYOUT (C/C++ files):\n"
        f"{source_layout_for_prompt(ctx)}\n\n"
        "SOURCE -> LEAN MAPPING (autogenerated):\n"
        f"{mapping_for_prompt(ctx)}\n\n"
        "LEAN FILES YOU ARE ALLOWED TO WRITE:\n"
        f"{writable_files_for_prompt(ctx)}\n\n"
        "SAFETY-CRITICAL RULES:\n"
        "- Never insert placeholder behavior. If you cannot implement something, you must read more files and implement it.\n"
        "- Do not 'assume true', 'stub', 'simplify away' semantics, or explain that you'd do more later.\n"
        "- Translated/runtime modules MUST NOT use 'sorry'. Only Verif.lean may contain sorry.\n"
        "- Verif.lean is proofs-only (anti-smuggling): no defs/instances/axioms/macros.\n\n"
        "WORKING STYLE:\n"
        "- Prefer simple, dependable data structures first (List/Array/Option/Nat/Int) *as long as semantics match*.\n"
        "- Keep IO minimal and deterministic.\n"
        "- When fixing build errors: resolve the first error with the smallest correct change.\n"
    )


def project_summary(ctx: dict) -> str:
    """Generate a project summary for translation."""
    from stages.llm import responses_create
    
    files = list_project_files(ctx["source_root"])
    src_files = [f for f in files if _is_source_file(f)]
    blobs: List[str] = []
    for rel in src_files[:8]:
        txt = _read_text_file(ctx["source_root"] / rel)
        blobs.append(f"FILE: {rel}\n" + trunc(txt, 2800) + "\n")
    
    instructions = (
        "Summarize this C/C++ codebase for a Lean translator.\n"
        "Return a concise, technical summary: key data structures, APIs, invariants, and control flow.\n"
        "Assume this is safety-critical production code.\n"
    )
    resp = responses_create(ctx, instructions=instructions, input_data="\n".join(blobs))
    summary = getattr(resp, "output_text", None) or "No summary."
    return summary


def base_instructions_cogen(ctx: dict) -> str:
    """Generate instructions for Stage 1: Co-Generation (translation mode)."""
    return (
        "ROLE: You are Anneal's Co-Generation Engine - an expert engineer who SIMULTANEOUSLY writes "
        "C implementations and their Lean 4 translations, ensuring semantic equivalence via differential testing.\n\n"
        "SETTING: SAFETY-CRITICAL. Correctness is mandatory. No placeholders, no stubs, no shortcuts.\n\n"
        "OBJECTIVE: Produce:\n"
        "1. Lean 4 DEFINITIONS (functions, structures, constants) that match C semantics\n"
        "2. Well-commented Lean code explaining the translation choices\n"
        "3. Test harnesses that verify C and Lean behave identically\n\n"
        f"PROJECT: {ctx['name']}\n"
        f"SOURCE ROOT: {ctx['source_root']}\n"
        f"SPEC ROOT: {SPEC_DIR}\n"
        f"SPEC SOURCE ROOT: {SPEC_SRC_DIR}\n\n"
        "HARD CONSTRAINTS:\n"
        "- You may ONLY write Lean files in the autogenerated writable set\n"
        "- Locked files are read-only:\n"
        f"{locked_files_for_prompt(ctx)}\n\n"
        "- Import policy: Each module MUST 'import Spec.Prelude'. No direct Std/Mathlib imports.\n\n"
        "SOURCE -> LEAN MAPPING:\n"
        f"{mapping_for_prompt(ctx)}\n\n"
        "WRITABLE LEAN FILES:\n"
        f"{writable_files_for_prompt(ctx)}\n\n"
        "WRITABLE TEXT FILES:\n"
        f"{chr(10).join(sorted(ctx['allowed_text_writes']))}\n\n"
        "STAGE 1 RULES:\n"
        "- Generate DEFINITIONS ONLY (no theorems/specs - those come in Stage 2)\n"
        "- NO 'sorry' allowed anywhere\n"
        "- Add EXTENSIVE COMMENTS explaining translation decisions\n"
        "- Run differential tests after each major change\n"
        "- Tests must pass with 5 runs x 5 cases before you can submit\n\n"
        "DIFFERENTIAL TESTING:\n"
        "- gen_inputs.py: generates random + edge-case command sequences\n"
        "- harness.c: parses commands, executes C impl, prints deterministic output\n"
        "- Harness.lean: parses same commands, executes Lean impl, prints same output\n"
        "- BOTH harnesses must produce IDENTICAL stdout for the same input\n\n"
        "OUTPUT COVERAGE REQUIREMENT:\n"
        "- At least 75% of test cases MUST produce non-empty output\n"
        "- Tests that just return early or produce no output are REJECTED as trivial\n"
        "- Generator must create inputs that exercise the function's core logic\n"
        "- Example: for two_sum, inputs must have valid pairs that produce 'Found: X Y' output\n\n"
        "WORKING STYLE:\n"
        "1. Read source file thoroughly\n"
        "2. Write Lean translation with comments\n"
        "3. Update harnesses to test the new code\n"
        "4. Run differential test\n"
        "5. Fix any mismatches\n"
        "6. Repeat until all files translated and tests pass\n"
        "7. Call submit_stage when complete\n"
    )


def base_instructions_prompt_cogen(ctx: dict) -> str:
    """Generate instructions for Stage 1: Prompt-driven Co-Generation (C only)."""
    prompt = ctx.get("prompt", "")
    
    return (
        "ROLE: You are Anneal's Co-Generation Engine - an expert engineer who SIMULTANEOUSLY generates "
        "a C implementation AND its Lean 4 equivalent from a natural language specification.\n\n"
        "SETTING: SAFETY-CRITICAL. Correctness is mandatory. No placeholders, no stubs, no shortcuts.\n\n"
        
        "═══════════════════════════════════════════════════════════════\n"
        "                    LEAN 4 IO REFERENCE\n"
        "═══════════════════════════════════════════════════════════════\n\n"
        
        "STDIN READING (correct pattern):\n"
        "  let stdin ← IO.getStdin\n"
        "  let line ← stdin.getLine    -- returns String with newline\n"
        "  let trimmed := line.trim    -- remove whitespace\n"
        "  if line.isEmpty then ...    -- EOF check\n\n"
        
        "STDOUT (correct pattern):\n"
        "  IO.println \"text\"           -- print with newline\n"
        "  IO.print \"text\"             -- print without newline\n\n"
        
        "WRONG APIS (do NOT use):\n"
        "  IO.getLine, IO.getLine?, IO.isEOF, IO.readStdin -- these don't exist!\n\n"
        
        "═══════════════════════════════════════════════════════════════\n"
        "                    LEAN-SYMPATHETIC CODE DESIGN\n"
        "═══════════════════════════════════════════════════════════════\n\n"
        
        "1. THINK IN LEAN FIRST\n"
        "   - Mentally design the Lean version, then write the implementation\n"
        "   - If you can't imagine how to write it in Lean, restructure the design\n\n"
        
        "2. FAVOR PURE FUNCTIONS\n"
        "   - Functions should be: (old_state, input) → (new_state, output)\n"
        "   - Minimize side effects; return new state instead of mutating\n\n"
        
        "3. USE IMMUTABLE DATA PATTERNS\n"
        "   - Even in C, structure code as if data were immutable\n"
        "   - Return new structs rather than modifying fields in place\n\n"
        
        "═══════════════════════════════════════════════════════════════\n"
        "                    CRITICAL: READ BEFORE WRITE\n"
        "═══════════════════════════════════════════════════════════════\n\n"
        
        "Before writing Harness.lean, you MUST:\n"
        "1. Call read_lean_file(\"generated/Main.lean\") to see your actual definitions\n"
        "2. Note the EXACT function and type names\n"
        "3. Use those exact names in Harness.lean\n\n"
        
        "DO NOT rely on memory for identifier names - you WILL get them wrong.\n"
        "If error says 'Unknown identifier X', read Main.lean to find correct name.\n\n"
        
        "═══════════════════════════════════════════════════════════════\n\n"
        
        f"PROJECT: {ctx['name']}\n"
        f"IMPLEMENTATION DIR: {ctx['source_root']}\n"
        f"LEAN DIR: {ctx['spec_src_root']}/{ctx['name']}/\n\n"
        
        "WRITABLE LEAN FILES:\n"
        f"{writable_files_for_prompt(ctx)}\n\n"
        
        "WRITABLE TEXT FILES:\n"
        f"{chr(10).join(sorted(ctx.get('allowed_text_writes', set())))}\n\n"
        
        "YOUR TASK:\n"
        f"Generate code based on this specification:\n\n{prompt}\n\n"
        
        "DELIVERABLES:\n"
        f"1. C implementation files in {ctx['source_root']}/\n"
        f"2. Equivalent Lean 4 definitions in spec/Spec/{ctx['name']}/Main.lean\n"
        "3. Test input generator: spec/tests/gen_inputs.py\n"
        "4. C test harness: spec/tests/harness.c\n"
        "5. Lean test harness: spec/Spec/tests/Harness.lean\n\n"
        
        "PROCESS:\n"
        "1. Design the data structures (thinking in Lean first)\n"
        "2. Write Main.lean with your implementation\n"
        "3. READ Main.lean back to confirm exact names\n"
        "4. Write Harness.lean using those exact names\n"
        "5. Run differential tests to verify equivalence\n"
        "6. Fix any mismatches until tests pass\n"
        "7. Call submit_stage when complete\n\n"
        
        "═══════════════════════════════════════════════════════════════\n"
        "                  PERFORMANCE GUIDELINES\n"
        "═══════════════════════════════════════════════════════════════\n\n"
        
        "Generate code that can handle BILLIONS of operations per second.\n"
        "These patterns apply across all target languages.\n\n"
        
        "1. INLINE HOT-PATH FUNCTIONS\n"
        "   - Small functions called frequently MUST be inlineable\n"
        "   - C: Use 'static inline' in headers for hot functions\n"
        "   - Rust: Use #[inline] or #[inline(always)] for hot paths\n"
        "   - If a function might be called billions of times, inline it\n\n"
        
        "2. AVOID DIVISION FOR ALIGNMENT\n"
        "   - WRONG: ((x + (a-1)) / a) * a   // division is slow\n"
        "   - RIGHT: (x + (a-1)) & ~(a-1)    // bitwise for power-of-2\n"
        "   - When alignment is power-of-2, ALWAYS use bitwise AND\n\n"
        
        "3. MINIMIZE STRUCT OVERHEAD ON HOT PATHS\n"
        "   - Return primitives instead of structs where possible\n"
        "   - Use out-parameters instead of returning result structs\n"
        "   - Keep hot-path data in registers, not memory\n\n"
        
        "4. PREFER BRANCHLESS CODE\n"
        "   - Branches cause pipeline stalls\n"
        "   - Use arithmetic: x = a + (b-a) * cond\n"
        "   - Use ternary operators which compile to cmov\n\n"
        
        "5. HOT PATH FIRST\n"
        "   - Put the common case as the if-branch, rare case as else\n"
        "   - Early return on error, fall through on success\n"
        "   - Reduces branch misprediction\n\n"
        
        "6. CACHE-FRIENDLY DATA LAYOUT\n"
        "   - Keep frequently accessed fields together\n"
        "   - Align to cache lines (64 bytes) for hot data\n"
        "   - Avoid pointer chasing; prefer contiguous arrays\n\n"
        
        "7. LANGUAGE-SPECIFIC OPTIMIZATIONS\n"
        "   C:\n"
        "   - 'static inline' for all small functions in headers\n"
        "   - 'restrict' keyword for non-aliasing pointers\n"
        "   - '__builtin_expect' for branch prediction hints\n"
        "   Rust:\n"
        "   - #[inline(always)] for critical paths\n"
        "   - Avoid unnecessary bounds checks with get_unchecked\n"
        "   - Use iterators over manual indexing\n\n"
        
        "GOAL: A bump allocator should do 1+ billion allocs/sec.\n"
        "If your design can't achieve this, restructure it.\n\n"
        
        "═══════════════════════════════════════════════════════════════\n\n"
        
        "ANTI-PATTERNS TO AVOID:\n"
        "- Hallucinating function names (always read your files)\n"
        "- Using non-existent Lean 4 IO APIs\n"
        "- Global mutable state\n"
        "- Pointer arithmetic without bounds\n"
        "- Division when bitwise AND would work\n"
        "- Non-inlined functions on hot paths\n"
    )

