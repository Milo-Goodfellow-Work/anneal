Generate formal specifications (theorems with proofs) for the Lean code in Spec.generated.Main.

CRITICAL INSTRUCTIONS:
1. DO NOT redefine any types or functions - they are already defined in Main.lean
2. IMPORT Main.lean using: import Spec.generated.Main
3. Only ADD theorems that prove properties about the EXISTING definitions
4. Write your output to Spec/generated/Verif.lean

The definitions you should prove properties about are in Main.lean:

```lean
import Spec.Prelude

namespace Spec.generated

/-- Cache line size used for alignment. -/
def cacheLine : Nat := 64

/-- Align `n` up to the next multiple of `a`.

This is defined for all `a`; callers should use power-of-two `a` (we use 64).
Uses arithmetic (division) to avoid needing bitwise complement on `Nat`.
-/
@[inline] def alignUp (n a : Nat) : Nat :=
  if a = 0 then n else ((n + (a - 1)) / a) * a

/-- A simple stack-based arena model. `cap` is total bytes.
`top` is current allocation offset. `marks` is a stack of saved `top` values.

This Lean model is purely functional; the C side will use mutable arrays.
-/
structure Arena where
  cap   : Nat
  top   : Nat
  marks : List Nat
  deriving Repr, BEq

@[inline] def Arena.init (cap : Nat) : Arena :=
  { cap := cap, top := 0, marks := [] }

@[inline] def Arena.push (a : Arena) : Arena :=
  { a with marks := a.top :: a.marks }

@[inline] def Arena.pop (a : Arena) : Arena :=
  match a.marks with
  | [] => a
  | m :: ms => { a with top := m, marks := ms }

@[inline] def Arena.reset (a : Arena) : Arena :=
  { a with top := 0, marks := [] }

/-- Allocate `n` bytes aligned to cache line.
Returns `(newArena, ok, offset)` where `offset` is start position if ok else 0.
-/
@[inline] def Arena.alloc (a : Arena) (n : Nat) : Arena × Bool × Nat :=
  let start := alignUp a.top cacheLine
  let newTop := start + n
  if newTop ≤ a.cap then
    ({ a with top := newTop }, true, start)
  else
    (a, false, 0)

@[inline] def Arena.remaining (a : Arena) : Nat :=
  if a.top ≤ a.cap then a.cap - a.top else 0

end Spec.generated

```

REQUIRED THEOREMS:
1. Structural invariants (e.g., data structure validity conditions)
2. Functional correctness (operations have expected effects)
3. Edge case handling (empty inputs, bounds, overflow)
4. Push/pop or similar operation inverses where applicable

OUTPUT FORMAT:
- Start with: import Spec.Prelude
- Then: import Spec.generated.Main
- Open namespace: namespace Spec.generated
- Add theorems referencing existing types like `Stack`, `stackPush`, etc.
- All proofs must be complete (no sorry)

Remember: DO NOT redefine Stack, StackRes, etc. They already exist in Main.lean.
