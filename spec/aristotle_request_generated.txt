Generate formal specifications (theorems with proofs) for the Lean code in Spec.generated.Main.

CRITICAL INSTRUCTIONS:
1. DO NOT redefine any types or functions - they are already defined in Main.lean
2. IMPORT Main.lean using: import Spec.generated.Main
3. Only ADD theorems that prove properties about the EXISTING definitions
4. Write your output to Spec/generated/Verif.lean

The definitions you should prove properties about are in Main.lean:

```lean
import Spec.Prelude

namespace Spec.generated

namespace Arena

structure State where
  capacity : Nat
  offset : Nat
  deriving Repr, Inhabited, BEq

def init (capacity : Nat) : State :=
  { capacity := capacity, offset := 0 }

def alloc (s : State) (size : Nat) : State Ã— Option Nat :=
  let alignment := 64
  -- (offset + 63) / 64 * 64
  let start := (s.offset + (alignment - 1)) / alignment * alignment
  if start + size > s.capacity then
    (s, none)
  else
    ({ s with offset := start + size }, some start)

def getPos (s : State) : Nat :=
  s.offset

def setPos (s : State) (pos : Nat) : State :=
  if pos <= s.capacity then
    { s with offset := pos }
  else
    s

def reset (s : State) : State :=
  { s with offset := 0 }

end Arena

end Spec.generated

```

REQUIRED THEOREMS:
1. Structural invariants (e.g., data structure validity conditions)
2. Functional correctness (operations have expected effects)
3. Edge case handling (empty inputs, bounds, overflow)
4. Push/pop or similar operation inverses where applicable

OUTPUT FORMAT:
- Start with: import Spec.Prelude
- Then: import Spec.generated.Main
- Open namespace: namespace Spec.generated
- Add theorems referencing existing types like `Stack`, `stackPush`, etc.
- All proofs must be complete (no sorry)

Remember: DO NOT redefine Stack, StackRes, etc. They already exist in Main.lean.
