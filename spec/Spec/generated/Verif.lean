/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d77183b0-3a30-416e-9ca9-1800bbfd20f9

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal verification of the Arena allocator in Spec.generated.Main.

This module contains theorems proving the correctness of the Arena allocator, including:
- Structural invariants: Alignment and bounds checks.
- Functional correctness: Initialization, allocation, and resetting.
- Edge case handling: Invalid alignment and insufficient capacity.
- Operation properties: Equivalence of reset operations.
-/

import Spec.Prelude
import Spec.generated.Main

namespace Spec.generated

/-!
# Formal Specifications

This file contains formal specifications (theorems) about the definitions in Main.lean.

## IMPORTANT FOR ARISTOTLE:
- All types and functions are ALREADY DEFINED in Main.lean
- Do NOT redefine Stack, StackRes, StackPopRes, etc.
- Only ADD theorems that prove properties about the existing definitions
- Reference definitions using their full names, e.g., `Spec.generated.Stack`
-/

-- Placeholder theorem (Aristotle will replace with real proofs)
#check @Nat.add

end Spec.generated


/-
Check if Spec.generated.Arena is available.
-/
#check Spec.generated.Arena

/-
isPow2 n returns true if and only if n is a power of two.
-/
theorem isPow2_iff (n : Nat) : Spec.generated.isPow2 n ↔ ∃ k, n = 2 ^ k := by
  have h_pow_of_two : ∀ {n : ℕ}, 0 < n → (n &&& (n - 1) = 0) → ∃ k : ℕ, n = 2 ^ k := by
    intro n hn h; induction' n using Nat.strongRecOn with n ih; rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> simp_all +decide [ Nat.pow_succ', Nat.mul_mod ] ;
    · rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.mul_succ, Nat.shiftRight_eq_div_pow ];
      · exists 1;
      · specialize ih ( k + 2 ) ( by linarith ) ( by linarith ) ; simp_all +decide [ Nat.add_comm, Nat.add_left_comm, Nat.add_assoc ];
        simp_all +decide [ show 2 + ( 2 + 2 * k ) = 2 * ( k + 2 ) by ring, show 2 * k + 3 = 2 * ( k + 1 ) + 1 by ring, Nat.add_mod, Nat.mul_mod, Nat.shiftRight_eq_div_pow ];
        have h_and_zero : ∀ {a b : ℕ}, (a &&& b) = 0 → (a / 2 &&& b / 2) = 0 := by
          intros a b hab; exact (by
          have h_and_zero : ∀ {a b : ℕ}, (a &&& b) = 0 → (a / 2 &&& b / 2) = 0 := by
            intros a b hab
            have h_and_zero : ∀ i, (a.testBit i) ∧ (b.testBit i) → False := by
              intro i hi; replace hab := congr_arg ( fun x => x.testBit i ) hab; simp_all +decide [ Nat.testBit_and ] ;
            have h_and_zero : ∀ i, (a / 2).testBit i ∧ (b / 2).testBit i → False := by
              intros i hi; specialize h_and_zero ( i + 1 ) ; simp_all +decide [ Nat.testBit_div_two ] ;
            exact Nat.eq_of_testBit_eq fun i => by specialize h_and_zero i; by_cases hi : ( a / 2 ).testBit i <;> by_cases hj : ( b / 2 ).testBit i <;> simp_all +decide ;
          exact h_and_zero hab);
        specialize h_and_zero h; simp_all +decide [ Nat.add_div ] ;
        exact Exists.elim ih fun x hx => ⟨ x + 1, by rw [ pow_succ', hx ] ⟩;
    · cases k <;> simp_all +decide [ Nat.pow_succ', Nat.mul_succ ];
      · exists 0;
      · have h_contra : (2 * ‹_› + 2) &&& (2 * ‹_› + 3) = 2 * ‹_› + 2 := by
          refine' Nat.eq_of_testBit_eq fun i => _;
          norm_num [ Nat.testBit_and ];
          rcases i with ( _ | i ) <;> simp_all +arith +decide [ Nat.testBit, Nat.shiftRight_eq_div_pow ];
          norm_num [ Nat.add_div, Nat.pow_succ', ← Nat.div_div_eq_div_mul ];
        grind;
  unfold Spec.generated.isPow2; aesop

/-
alignUp x a is greater than or equal to x, provided a > 0.
-/
theorem alignUp_ge (x a : Nat) (ha : a > 0) : Spec.generated.alignUp x a ≥ x := by
  unfold Spec.generated.alignUp;
  linarith [ Nat.div_add_mod ( x + ( a - 1 ) ) a, Nat.mod_lt ( x + ( a - 1 ) ) ha, Nat.sub_add_cancel ha ]

/-
arenaInit creates an arena with the specified capacity and 0 top.
-/
theorem arenaInit_spec (c : Nat) :
  let a := Spec.generated.arenaInit c
  a.capacity = c ∧ a.top = 0 := by
    exact ⟨ rfl, rfl ⟩

/-
alignUp x a is divisible by a, provided a > 0.
-/
theorem alignUp_dvd (x a : Nat) (ha : a > 0) : a ∣ Spec.generated.alignUp x a := by
  exact ⟨ ( x + ( a - 1 ) ) / a, by unfold Spec.generated.alignUp; ring ⟩

/-
If arenaAlloc succeeds, the returned offset is a multiple of the alignment.
-/
theorem arenaAlloc_ok_implies_aligned (a : Spec.generated.Arena) (size align : Nat) :
  let res := Spec.generated.arenaAlloc a size align
  res.2.ok → align > 0 ∧ align ∣ res.2.offset := by
    unfold Spec.generated.arenaAlloc;
    split_ifs <;> simp_all +decide;
    split_ifs <;> simp_all +decide;
    exact ⟨ Nat.pos_of_ne_zero ( by rintro rfl; contradiction ), alignUp_dvd _ _ ( Nat.pos_of_ne_zero ( by rintro rfl; contradiction ) ) ⟩

/-
If arenaAlloc succeeds, the allocated block fits within the arena's capacity.
-/
theorem arenaAlloc_ok_implies_in_bounds (a : Spec.generated.Arena) (size align : Nat) :
  let res := Spec.generated.arenaAlloc a size align
  res.2.ok → res.2.offset + res.2.size ≤ a.capacity := by
    unfold Spec.generated.arenaAlloc;
    grind

/-
arenaUsed returns the top field of the arena.
-/
theorem arenaUsed_spec (a : Spec.generated.Arena) : Spec.generated.arenaUsed a = a.top := by
  rfl

/-
The sum of used and remaining space equals the capacity, provided the top pointer is within bounds.
-/
theorem arenaRemaining_spec (a : Spec.generated.Arena) (h : a.top ≤ a.capacity) :
  Spec.generated.arenaRemaining a + Spec.generated.arenaUsed a = a.capacity := by
    -- By definition of `arenaRemaining`, we have `arenaRemaining a = a.capacity - a.top`.
    simp [Spec.generated.arenaRemaining, Spec.generated.arenaUsed, h];
    grind

/-
arenaReset sets top to 0 and preserves capacity.
-/
theorem arenaReset_spec (a : Spec.generated.Arena) :
  let a' := Spec.generated.arenaReset a
  a'.top = 0 ∧ a'.capacity = a.capacity := by
    aesop

/-
arenaResetToMark sets top to mark if mark is <= current top.
-/
theorem arenaResetToMark_le (a : Spec.generated.Arena) (mark : Nat) (h : mark ≤ a.top) :
  (Spec.generated.arenaResetToMark a mark).top = mark := by
    unfold Spec.generated.arenaResetToMark; aesop;

/-
arenaAlloc fails if align is not a power of two.
-/
theorem arenaAlloc_fail_invalid_align (a : Spec.generated.Arena) (size align : Nat) (h : ¬ Spec.generated.isPow2 align) :
  (Spec.generated.arenaAlloc a size align).2.ok = false := by
    unfold Spec.generated.arenaAlloc; aesop;

/-
arenaAllocCacheLine is equivalent to arenaAlloc with cacheLine alignment.
-/
theorem arenaAllocCacheLine_spec (a : Spec.generated.Arena) (size : Nat) :
  Spec.generated.arenaAllocCacheLine a size = Spec.generated.arenaAlloc a size Spec.generated.cacheLine := by
    rfl

/-
If arenaAlloc succeeds, the arena's top is updated to offset + size.
-/
theorem arenaAlloc_success_update (a : Spec.generated.Arena) (size align : Nat) :
  let res := Spec.generated.arenaAlloc a size align
  res.2.ok → res.1.top = res.2.offset + res.2.size := by
    unfold Spec.generated.arenaAlloc; aesop;

/-
arenaAlloc fails if there is insufficient space after alignment.
-/
theorem arenaAlloc_fail_no_space (a : Spec.generated.Arena) (size align : Nat) (h_align : Spec.generated.isPow2 align) :
  let alignedTop := Spec.generated.alignUp a.top align
  alignedTop + size > a.capacity → (Spec.generated.arenaAlloc a size align).2.ok = false := by
    unfold Spec.generated.arenaAlloc;
    grind

/-
arenaMark returns the top field of the arena.
-/
theorem arenaMark_spec (a : Spec.generated.Arena) : Spec.generated.arenaMark a = a.top := by
  rfl

/-
arenaResetToMark does nothing if mark is greater than current top.
-/
theorem arenaResetToMark_gt (a : Spec.generated.Arena) (mark : Nat) (h : mark > a.top) :
  Spec.generated.arenaResetToMark a mark = a := by
    -- By definition of `arenaResetToMark`, if `mark > a.top`, then the arena's top remains `a.top`.
    simp [Spec.generated.arenaResetToMark, h]

/-
Resetting to mark 0 is equivalent to a full reset.
-/
theorem arenaResetToMark_zero_eq_reset (a : Spec.generated.Arena) :
  Spec.generated.arenaResetToMark a 0 = Spec.generated.arenaReset a := by
    -- By definition of `arenaResetToMark`, if the mark is 0, then the arena is reset to its initial state.
    simp [Spec.generated.arenaResetToMark, Spec.generated.arenaReset]