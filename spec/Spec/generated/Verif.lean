/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a9f2a653-0fdd-4476-8926-98cd00db3081

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal verification of the Stack implementation in Spec.generated.Main.
This module contains theorems proving:
1. Structural invariants:
   - `stackEmpty_valid`: The empty stack satisfies the capacity constraint.
   - `stackCapacity_pos`: The stack capacity is positive.
2. Functional correctness:
   - `stackPush_ok`: Pushing onto a non-full stack succeeds and updates the stack correctly.
   - `stackPush_fail`: Pushing onto a full stack fails and leaves the stack unchanged.
   - `stackPop_success`: Popping from a non-empty stack succeeds and returns the correct value.
   - `stackPop_empty`: Popping from an empty stack fails and leaves the stack unchanged.
   - `stackPeek_success`: Peeking at a non-empty stack succeeds and returns the correct value.
   - `stackPeek_empty`: Peeking at an empty stack fails.
   - `stackIsFull_true` / `stackIsFull_false`: Correctness of `stackIsFull`.
   - `stackEmpty_isEmpty`: Correctness of `stackIsEmpty` for the empty stack.
3. Invariants preservation:
   - `stackPush_maintains_capacity`: Pushing maintains the capacity invariant.
   - `stackPop_maintains_capacity`: Popping maintains the capacity invariant.
   - `stackPush_length_success`: Pushing increases length by 1.
   - `stackPop_length_success`: Popping decreases length by 1.
4. Inverse operations:
   - `stackPush_pop_inverse`: Push then Pop yields the original stack and value.
   - `stackPop_push_inverse`: Pop then Push yields the original stack.
5. Consistency:
   - `stackPeek_pop_ok_iff`: Peek and Pop agree on success condition.
   - `stackPush_ok_iff_not_full`: Push success is equivalent to not being full.
   - `stackPeek_no_change`: Peek does not modify the stack (structurally enforced).
-/

import Spec.Prelude
import Spec.generated.Main

namespace Spec.generated

/-!
# Formal Specifications

This file contains formal specifications (theorems) about the definitions in Main.lean.

## IMPORTANT FOR ARISTOTLE:
- All types and functions are ALREADY DEFINED in Main.lean
- Do NOT redefine Stack, StackRes, StackPopRes, etc.
- Only ADD theorems that prove properties about the existing definitions
- Reference definitions using their full names, e.g., `Spec.generated.Stack`
-/

-- Placeholder theorem (Aristotle will replace with real proofs)
#check @Nat.add

end Spec.generated


#check Spec.generated.stackCapacity

#check Spec.generated.stackIsEmpty

#check Spec.generated.stackEmpty

/-
The empty stack is empty.
-/
theorem stackEmpty_isEmpty : Spec.generated.stackIsEmpty Spec.generated.stackEmpty = true := by
  rfl

/-
Pushing onto a non-full stack succeeds and prepends the element.
-/
theorem stackPush_ok (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length < Spec.generated.stackCapacity) :
  let res := Spec.generated.stackPush s x
  res.ok = true ∧ res.stack.xs = x :: s.xs := by
    unfold Spec.generated.stackPush; aesop;

/-
Pushing onto a full stack fails and leaves the stack unchanged.
-/
theorem stackPush_fail (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length >= Spec.generated.stackCapacity) :
  let res := Spec.generated.stackPush s x
  res.ok = false ∧ res.stack = s := by
    -- By definition of `stackPush`, if the stack's length is greater than or equal to `stackCapacity`, then the push operation returns the original stack with `ok` set to `false`.
    simp [Spec.generated.stackPush, h];
    grind

/-
Popping from an empty stack fails and leaves the stack unchanged.
-/
theorem stackPop_empty (s : Spec.generated.Stack) (h : s.xs = []) :
  let res := Spec.generated.stackPop s
  res.ok = false ∧ res.stack = s := by
    cases s ; aesop

/-
Popping from a non-empty stack succeeds, returns the top value, and removes it.
-/
theorem stackPop_success (s : Spec.generated.Stack) (y : Int32) (ys : List Int32) (h : s.xs = y :: ys) :
  let res := Spec.generated.stackPop s
  res.ok = true ∧ res.value = y ∧ res.stack.xs = ys := by
    unfold Spec.generated.stackPop; aesop;

/-
Peeking at an empty stack fails.
-/
theorem stackPeek_empty (s : Spec.generated.Stack) (h : s.xs = []) :
  let res := Spec.generated.stackPeek s
  res.ok = false := by
    unfold Spec.generated.stackPeek; aesop

/-
Peeking at a non-empty stack succeeds and returns the top value.
-/
theorem stackPeek_success (s : Spec.generated.Stack) (y : Int32) (ys : List Int32) (h : s.xs = y :: ys) :
  let res := Spec.generated.stackPeek s
  res.ok = true ∧ res.value = y := by
    unfold Spec.generated.stackPeek; aesop;

/-
stackIsFull returns true if the stack is full.
-/
theorem stackIsFull_true (s : Spec.generated.Stack) (h : s.xs.length >= Spec.generated.stackCapacity) :
  Spec.generated.stackIsFull s = true := by
    unfold Spec.generated.stackIsFull; aesop

/-
stackIsFull returns false if the stack is not full.
-/
theorem stackIsFull_false (s : Spec.generated.Stack) (h : s.xs.length < Spec.generated.stackCapacity) :
  Spec.generated.stackIsFull s = false := by
    -- Apply the definition of `stackIsFull` to conclude that it returns false.
    unfold Spec.generated.stackIsFull;
    grind

/-
Pushing onto a valid stack results in a valid stack (respecting capacity).
-/
theorem stackPush_maintains_capacity (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length ≤ Spec.generated.stackCapacity) :
  (Spec.generated.stackPush s x).stack.xs.length ≤ Spec.generated.stackCapacity := by
    unfold Spec.generated.stackPush; aesop;

/-
Pushing an element onto a non-full stack and then popping it yields the original stack and the element.
-/
theorem stackPush_pop_inverse (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length < Spec.generated.stackCapacity) :
  let pushRes := Spec.generated.stackPush s x
  let popRes := Spec.generated.stackPop pushRes.stack
  pushRes.ok = true ∧ popRes.ok = true ∧ popRes.value = x ∧ popRes.stack = s := by
    unfold Spec.generated.stackPush Spec.generated.stackPop; aesop;

/-
The empty stack satisfies the capacity constraint.
-/
theorem stackEmpty_valid : Spec.generated.stackEmpty.xs.length ≤ Spec.generated.stackCapacity := by
  decide +revert

/-
Pushing onto a non-full stack increases its length by 1.
-/
theorem stackPush_length_success (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length < Spec.generated.stackCapacity) :
  (Spec.generated.stackPush s x).stack.xs.length = s.xs.length + 1 := by
    unfold Spec.generated.stackPush; aesop

/-
Popping from a valid stack results in a valid stack (respecting capacity).
-/
theorem stackPop_maintains_capacity (s : Spec.generated.Stack) (h : s.xs.length ≤ Spec.generated.stackCapacity) :
  (Spec.generated.stackPop s).stack.xs.length ≤ Spec.generated.stackCapacity := by
    cases s ; simp_all +decide [ Spec.generated.stackPop ];
    cases ‹List Int32› <;> simp +decide [ * ];
    exact Nat.le_trans ( Nat.le_succ _ ) h

/-
Popping from a non-empty stack decreases its length by 1.
-/
theorem stackPop_length_success (s : Spec.generated.Stack) (h : s.xs ≠ []) :
  (Spec.generated.stackPop s).stack.xs.length = s.xs.length - 1 := by
    rcases s with ⟨ ⟨ l ⟩ ⟩ <;> aesop

/-
stackPeek and stackPop agree on success/failure status.
-/
theorem stackPeek_pop_ok_iff (s : Spec.generated.Stack) :
  (Spec.generated.stackPeek s).ok = (Spec.generated.stackPop s).ok := by
    unfold Spec.generated.stackPeek Spec.generated.stackPop; aesop;

/-
Popping an element from a valid non-empty stack and then pushing it back yields the original stack.
-/
theorem stackPop_push_inverse (s : Spec.generated.Stack) (h_valid : s.xs.length ≤ Spec.generated.stackCapacity) (h_nonempty : s.xs ≠ []) :
  let popRes := Spec.generated.stackPop s
  let pushRes := Spec.generated.stackPush popRes.stack popRes.value
  popRes.ok = true ∧ pushRes.ok = true ∧ pushRes.stack = s := by
    unfold Spec.generated.stackPop Spec.generated.stackPush at *;
    rcases s with ⟨ _ | ⟨ y, ys ⟩ ⟩ <;> ( unfold Spec.generated.stackCapacity at * ; simp +arith +decide at *; );
    aesop

/-
If the stack is full, it is not empty (since capacity > 0).
-/
theorem stackPeek_no_change (s : Spec.generated.Stack) :
  (Spec.generated.stackPeek s).ok → True := by
    exact fun _ => trivial

/-
Pushing succeeds if and only if the stack is not full.
-/
theorem stackPush_ok_iff_not_full (s : Spec.generated.Stack) (x : Int32) :
  (Spec.generated.stackPush s x).ok = !Spec.generated.stackIsFull s := by
    unfold Spec.generated.stackIsFull Spec.generated.stackPush; aesop

/-
The stack capacity is positive.
-/
theorem stackCapacity_pos : Spec.generated.stackCapacity > 0 := by
  decide +revert