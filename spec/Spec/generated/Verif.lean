/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 147d9809-0735-4a5f-8df4-4ffaa5bf3086

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
Formal specifications for the Stack implementation in Spec.generated.Main.
Includes structural invariants (Stack.isValid) and correctness theorems for all public operations (push, pop, peek, empty, full), covering both success and failure cases.
-/

import Spec.Prelude

namespace Spec.generated

/-- Fixed capacity; must match C. -/
def stackCapacity : Nat := 32

/-- Stack represented as a list (top at head). This is pure and total.
Capacity is enforced by operations (list length never exceeds `stackCapacity`). -/
structure Stack where
  xs : List Int32
  deriving Repr, DecidableEq

def stackEmpty : Stack := { xs := [] }

def stackIsEmpty (s : Stack) : Bool := s.xs.isEmpty

def stackIsFull (s : Stack) : Bool := s.xs.length ≥ stackCapacity

structure StackRes where
  stack : Stack
  ok : Bool
  deriving Repr, DecidableEq

structure StackPopRes where
  stack : Stack
  value : Int32
  ok : Bool
  deriving Repr, DecidableEq

structure StackPeekRes where
  value : Int32
  ok : Bool
  deriving Repr, DecidableEq

def stackPush (s : Stack) (x : Int32) : StackRes :=
  if s.xs.length < stackCapacity then
    { stack := { xs := x :: s.xs }, ok := true }
  else
    { stack := s, ok := false }

def stackPop (s : Stack) : StackPopRes :=
  match s.xs with
  | [] => { stack := s, value := 0, ok := false }
  | y :: ys => { stack := { xs := ys }, value := y, ok := true }

def stackPeek (s : Stack) : StackPeekRes :=
  match s.xs with
  | [] => { value := 0, ok := false }
  | y :: _ => { value := y, ok := true }

end Spec.generated


/-
A stack is valid if its underlying list length is less than or equal to the stack capacity.
-/
def Spec.generated.Stack.isValid (s : Spec.generated.Stack) : Prop :=
  s.xs.length ≤ Spec.generated.stackCapacity

/-
The empty stack is valid.
-/
theorem Spec.generated.stackEmpty_isValid : Spec.generated.stackEmpty.isValid := by
  -- The empty stack is valid since its length is 0, which is less than or equal to the capacity.
  simp [Spec.generated.stackEmpty, Spec.generated.stackCapacity, Spec.generated.Stack.isValid]

/-
Pushing to a valid stack results in a valid stack.
-/
theorem Spec.generated.stackPush_preserves_validity (s : Spec.generated.Stack) (x : Int32) (h : s.isValid) :
  (Spec.generated.stackPush s x).stack.isValid := by
  -- By definition of `stackPush`, the resulting stack is either valid (if the original stack wasn't full) or the same as the original stack (if it was full), both of which are valid.
  unfold Spec.generated.stackPush; aesop

/-
Popping from a valid stack results in a valid stack.
-/
theorem Spec.generated.stackPop_preserves_validity (s : Spec.generated.Stack) (h : s.isValid) :
  (Spec.generated.stackPop s).stack.isValid := by
  unfold Spec.generated.stackPop Spec.generated.Stack.isValid at *;
  grind

/-
If the stack is not full, pushing succeeds and the element is added to the top.
-/
theorem Spec.generated.stackPush_ok_of_not_full (s : Spec.generated.Stack) (x : Int32) (h : ¬ s.xs.length ≥ Spec.generated.stackCapacity) :
  let res := Spec.generated.stackPush s x
  res.ok ∧ res.stack.xs = x :: s.xs := by
  unfold Spec.generated.stackPush; aesop;

/-
If the stack is full, pushing fails and the stack remains unchanged.
-/
theorem Spec.generated.stackPush_fail_of_full (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length ≥ Spec.generated.stackCapacity) :
  let res := Spec.generated.stackPush s x
  ¬ res.ok ∧ res.stack = s := by
  unfold stackPush;
  grind

/-
If the stack is empty, popping fails and returns 0.
-/
theorem Spec.generated.stackPop_fail_of_empty (s : Spec.generated.Stack) (h : s.xs = []) :
  let res := Spec.generated.stackPop s
  ¬ res.ok ∧ res.stack = s ∧ res.value = 0 := by
  unfold stackPop; aesop

/-
If the stack is not empty, peeking succeeds and returns the top element.
-/
theorem Spec.generated.stackPeek_ok_of_not_empty (s : Spec.generated.Stack) (h : s.xs ≠ []) :
  let res := Spec.generated.stackPeek s
  res.ok ∧ ∃ y ys, s.xs = y :: ys ∧ res.value = y := by
  unfold stackPeek; cases s; aesop;

/-
If the stack is empty, peeking fails and returns 0.
-/
theorem Spec.generated.stackPeek_fail_of_empty (s : Spec.generated.Stack) (h : s.xs = []) :
  let res := Spec.generated.stackPeek s
  ¬ res.ok ∧ res.value = 0 := by
  unfold stackPeek; aesop;

/-
If the stack is not empty, popping succeeds and removes the top element.
-/
theorem Spec.generated.stackPop_ok_of_not_empty (s : Spec.generated.Stack) (h : s.xs ≠ []) :
  let res := Spec.generated.stackPop s
  res.ok ∧ ∃ y ys, s.xs = y :: ys ∧ res.value = y ∧ res.stack.xs = ys := by
  unfold stackPop; aesop;

/-
stackIsEmpty returns true if and only if the underlying list is empty.
-/
theorem Spec.generated.stackIsEmpty_iff (s : Spec.generated.Stack) :
  Spec.generated.stackIsEmpty s ↔ s.xs = [] := by
  unfold stackIsEmpty;
  grind

/-
stackIsFull returns true if and only if the underlying list length is at least the capacity.
-/
theorem Spec.generated.stackIsFull_iff (s : Spec.generated.Stack) :
  Spec.generated.stackIsFull s ↔ s.xs.length ≥ Spec.generated.stackCapacity := by
  unfold stackIsFull; aesop;

/-
Pushing an element (if not full) and then popping it returns the element and restores the original stack.
-/
theorem Spec.generated.stackPush_then_stackPop (s : Spec.generated.Stack) (x : Int32) (h : ¬ s.xs.length ≥ Spec.generated.stackCapacity) :
  let resPush := Spec.generated.stackPush s x
  let resPop := Spec.generated.stackPop resPush.stack
  resPush.ok ∧ resPop.ok ∧ resPop.value = x ∧ resPop.stack = s := by
  unfold stackPush stackPop at * ; aesop

/-
Pushing to a non-full stack increases its length by 1.
-/
theorem Spec.generated.stackPush_length_success (s : Spec.generated.Stack) (x : Int32) (h : ¬ s.xs.length ≥ Spec.generated.stackCapacity) :
  (Spec.generated.stackPush s x).stack.xs.length = s.xs.length + 1 := by
  unfold stackPush; aesop;

/-
Popping from a non-empty stack decreases its length by 1.
-/
theorem Spec.generated.stackPop_length_success (s : Spec.generated.Stack) (h : s.xs ≠ []) :
  (Spec.generated.stackPop s).stack.xs.length = s.xs.length - 1 := by
  -- By definition of `stackPop`, if the stack is not empty, the top element is returned and the stack is reduced by one element.
  unfold Spec.generated.stackPop;
  aesop

/-
stackPeek returns the same value and status as stackPop.
-/
theorem Spec.generated.stackPeek_eq_stackPop_value (s : Spec.generated.Stack) :
  let resPeek := Spec.generated.stackPeek s
  let resPop := Spec.generated.stackPop s
  resPeek.ok = resPop.ok ∧ resPeek.value = resPop.value := by
  unfold stackPeek stackPop; aesop;

/-
Pushing to a full stack does not change its length.
-/
theorem Spec.generated.stackPush_length_fail (s : Spec.generated.Stack) (x : Int32) (h : s.xs.length ≥ Spec.generated.stackCapacity) :
  (Spec.generated.stackPush s x).stack.xs.length = s.xs.length := by
  unfold stackPush;
  grind

/-
The initial empty stack is reported as empty.
-/
theorem Spec.generated.stackEmpty_isEmpty : Spec.generated.stackIsEmpty Spec.generated.stackEmpty := by
  rfl
