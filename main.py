#!/usr/bin/env python3
"""
Anneal - Universal Verification Agent

Procedural entry point. Orchestrates the verification pipeline as a simple
sequence of function calls with shared state passed via context dict.
"""
from pathlib import Path

from openai import OpenAI

from helpers import (
    log, load_secrets, ensure_prelude_and_lockdown,
    SPEC_DIR, SPEC_SRC_DIR, EXAMPLES_DIR,
    DIFF_REQUIRED_RUNS, DIFF_MIN_CASES_PER_RUN,
    LOCKED_LEAN_FILENAMES,
)

from stages.scaffold import autogen_scaffold_and_lockdown
from stages.translation import run_stage_translation
from stages.equivalence import run_stage_equivalence
from stages.specification import run_stage_specification
from stages.hardening import run_stage_hardening
from stages.verification import run_stage_verification
from stages.llm import RestartTranslationError

# Skip flags - module level, can be mutated by kickback
SKIP_TO_EQUIVALENCE = True
SKIP_TO_HARDENING = False
SKIP_TO_SPECIFICATION = False
SKIP_TO_VERIFICATION = False


def main() -> None:
    log("=== Anneal Universal Verification Agent ===")
    ensure_prelude_and_lockdown()
    
    secrets = load_secrets()
    client = OpenAI(api_key=secrets["secrets"]["OPENAI_API_KEY"])

    if not EXAMPLES_DIR.exists():
        log(f"No source projects found in {EXAMPLES_DIR}")
        return

    examples = [d for d in EXAMPLES_DIR.iterdir() if d.is_dir()]
    if not examples:
        log("No source projects found.")
        return

    for ex in examples:
        project_name = ex.name
        project_path = ex
        
        # Create project context (shared state dict)
        spec_project_root = SPEC_SRC_DIR / project_name
        spec_project_root.mkdir(parents=True, exist_ok=True)
        
        ctx = {
            "name": project_name,
            "source_root": project_path,
            "spec_pkg_root": SPEC_DIR,
            "spec_src_root": SPEC_SRC_DIR,
            "spec_project_root": spec_project_root,
            "client": client,
            "secrets": secrets,
            # Autogenerated write-allowlists (populated by scaffold)
            "allowed_lean_writes": set(),
            "allowed_text_writes": set(),
            "locked_lean_paths": set(LOCKED_LEAN_FILENAMES),
            # Source->Lean mapping (populated by scaffold)
            "src_to_lean": {},
            "lean_to_src": {},
            # Stage tracking
            "current_stage": "INIT",
            "equiv_state": {
                "last_report": None,
                "passed_runs": 0,
                "required_runs": DIFF_REQUIRED_RUNS,
                "min_cases_per_run": DIFF_MIN_CASES_PER_RUN,
                "last_status": "unknown",
            },
            # Paths
            "safety_case_rel": f"spec/reports/{project_name}_SafetyCase.md",
            "equiv_report_rel": f"spec/reports/{project_name}_EquivalenceReport.json",
        }
        
        log(f"=== Processing Project: {project_name} ===")
        
        # Scaffold and lockdown
        autogen_scaffold_and_lockdown(ctx)
        
        if not ctx["src_to_lean"]:
            log("No source mapping; skipping.")
            continue

        # Run pipeline with kickback support
        restart_reason = None
        skip_equiv = SKIP_TO_EQUIVALENCE
        skip_hard = SKIP_TO_HARDENING
        skip_spec = SKIP_TO_SPECIFICATION
        skip_verif = SKIP_TO_VERIFICATION
        
        while True:
            try:
                # Translation stage
                if not skip_equiv and not skip_hard and not skip_verif and not skip_spec:
                    run_stage_translation(ctx, restart_reason=restart_reason)
                elif skip_verif:
                    log("Skipping Translation stage (SKIP_TO_VERIFICATION=True).")
                elif skip_hard:
                    log("Skipping Translation stage (SKIP_TO_HARDENING=True).")
                elif skip_spec:
                    log("Skipping Translation stage (SKIP_TO_SPECIFICATION=True).")
                else:
                    log("Skipping Translation stage (SKIP_TO_EQUIVALENCE=True).")

                # Equivalence stage
                if not skip_hard and not skip_verif and not skip_spec:
                    run_stage_equivalence(ctx)
                else:
                    log("Skipping Equivalence stage.")

                # Specification and Hardening stages
                if not skip_verif:
                    run_stage_specification(ctx)
                    run_stage_hardening(ctx)
                else:
                    log("Skipping Spec & Hardening stages (SKIP_TO_VERIFICATION=True).")

                # Verification stage
                run_stage_verification(ctx)

                # All stages passed - exit loop
                break

            except RestartTranslationError as e:
                log(f"\n!!! KICKBACK TRIGGERED: {e.reason} !!!")
                log("Restarting Translation Stage with fresh context...\n")
                restart_reason = e.reason
                if skip_equiv or skip_hard or skip_verif or skip_spec:
                    log("WARNING: Kickback triggered but SKIP flags are active. Disabling all SKIP flags.")
                    skip_equiv = False
                    skip_spec = False
                continue


if __name__ == "__main__":
    main()
